# Порівняння алгоритмів сортування

## Опис
У цьому завданні ми порівнюємо три алгоритми сортування: Merge Sort, Insertion Sort та Timsort. Для кожного алгоритму вимірюється час виконання на різних наборах даних, щоб зрозуміти їх ефективність у реальних умовах.

Алгоритм **Timsort** є вбудованим алгоритмом сортування в Python і поєднує переваги сортування злиттям і сортування вставками. Ми протестуємо всі три алгоритми на масивах різних розмірів, щоб перевірити їх швидкість.

## Результати вимірювань часу виконання

| Розмір масиву | Merge Sort Time (сек) | Insertion Sort Time (сек) | Timsort Time (сек) |
|----------------|-----------------------|---------------------------|--------------------|
| 100            | 0.000988              | 0.001479                  | 0.000032           |
| 1000           | 0.013592              | 0.174854                  | 0.000616           |
| 5000           | 0.084954              | 4.305575                  | 0.003955           |
| 10000          | 0.184127              | 17.769220                 | 0.008641           |

## Аналіз:

1. **Алгоритм сортування злиттям (Merge Sort)** показав стабільно хороші результати, з часом виконання, що зростає логарифмічно відносно збільшення розміру масиву. Це підтверджує його складність O(n log n), що робить його ефективним для великих масивів.

2. **Алгоритм сортування вставками (Insertion Sort)** працює набагато повільніше, зокрема на великих масивах. Його час виконання зростає квадратично (O(n^2)), що стає помітно на великих розмірах масиву. Однак для маленьких масивів або майже відсортованих даних він може працювати швидше.

3. **Timsort** (вбудований в Python) демонструє значно кращі результати, з часом виконання, який залишається значно нижчим порівняно з Merge Sort і Insertion Sort для всіх розмірів масиву. Це підтверджує, що Timsort, який поєднує стратегії сортування злиттям та вставками, значно ефективніший для реальних сценаріїв, ніж простіші алгоритми.

## Висновки:

- **Timsort** є найефективнішим алгоритмом для сортування на реальних даних. Це підтверджується його часом виконання, що перевищує навіть ефективність сортування злиттям, завдяки поєднанню двох технік.
- **Merge Sort** також має стабільно хорошу ефективність для великих масивів, але Timsort показав кращі результати завдяки додатковим оптимізаціям.
- **Insertion Sort** є найменш ефективним на великих масивах, хоча на малих масивах або майже відсортованих даних він може працювати швидше.
